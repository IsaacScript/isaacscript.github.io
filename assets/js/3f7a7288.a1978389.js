"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[80935],{21804:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var i=t(31085),a=t(71184);const o={title:"JavaScript/TypeScript Tutorial"},s=void 0,r={id:"main/javascript-tutorial",title:"JavaScript/TypeScript Tutorial",description:"If you have never programmed in JavaScript/TypeScript before, but you have programmed in Lua, then this page is for you. Below, you can compare Lua code side by side with the equivalent TypeScript code. If you have coded a mod in Lua before, reading through this page will probably be enough to get you started.",source:"@site/docs/main/javascript-tutorial.md",sourceDirName:"main",slug:"/main/javascript-tutorial",permalink:"/main/javascript-tutorial",draft:!1,unlisted:!1,editUrl:"https://github.com/IsaacScript/isaacscript/edit/main/packages/docs/docs/main/javascript-tutorial.md",tags:[],version:"current",frontMatter:{title:"JavaScript/TypeScript Tutorial"},sidebar:"docs",previous:{title:"Project Directory Structure",permalink:"/main/directory-structure"},next:{title:"Building an Example Mod",permalink:"/main/example-mod"}},l={},c=[{value:"Level 1 - Basic",id:"level-1---basic",level:2},{value:"Comments",id:"comments",level:3},{value:"Semi-Colons",id:"semi-colons",level:3},{value:"Colons",id:"colons",level:3},{value:"Variables: <code>local</code> \u279c <code>const</code> and <code>let</code>",id:"variables-local--const-and-let",level:3},{value:"Functions",id:"functions",level:3},{value:"Anonymous Functions",id:"anonymous-functions",level:3},{value:"Arrays",id:"arrays",level:3},{value:"Objects",id:"objects",level:3},{value:"<code>if</code> Statements and Operators",id:"if-statements-and-operators",level:3},{value:"<code>for</code> Statements for Counting",id:"for-statements-for-counting",level:3},{value:"<code>for</code> Statements for Arrays",id:"for-statements-for-arrays",level:3},{value:"<code>for</code> Statements for Key/Value Tables",id:"for-statements-for-keyvalue-tables",level:3},{value:"<code>nil</code> \u279c <code>undefined</code>",id:"nil--undefined",level:3},{value:"Level 2 - Intermediate",id:"level-2---intermediate",level:2},{value:"Assignment Operators",id:"assignment-operators",level:3},{value:"Increment and Decrement Operators",id:"increment-and-decrement-operators",level:3},{value:"String Concatenation",id:"string-concatenation",level:3},{value:"String Conversion",id:"string-conversion",level:3},{value:"String Templates",id:"string-templates",level:3},{value:"TypeScript Type Annotations",id:"typescript-type-annotations",level:3},{value:"Type Inference For Variables",id:"type-inference-for-variables",level:3},{value:"Type Inference For Functions",id:"type-inference-for-functions",level:3},{value:"Void",id:"void",level:3},{value:"Splitting Your Code Into Multiple Files: <code>require()</code> \u279c <code>import</code>",id:"splitting-your-code-into-multiple-files-require--import",level:3},{value:"<code>main.lua</code>",id:"mainlua",level:4},{value:"<code>revelations/callbacks/postGameStarted.lua</code>",id:"revelationscallbackspostgamestartedlua",level:4},{value:"<code>main.ts</code>",id:"maints",level:4},{value:"<code>callbacks/postGameStarted.ts</code>",id:"callbackspostgamestartedts",level:4},{value:"Level 3 - Advanced",id:"level-3---advanced",level:2},{value:"Using Global Variables",id:"using-global-variables",level:3},{value:"Option 1 - Inline Declarations",id:"option-1---inline-declarations",level:4},{value:"Option 2 - A Declaration File",id:"option-2---a-declaration-file",level:4},{value:"Creating Global Variables",id:"creating-global-variables",level:3},{value:"Enums",id:"enums",level:3},{value:"Maps",id:"maps",level:3},{value:"Type Narrowing",id:"type-narrowing",level:3}];function d(e){const n={a:"a",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["If you have never programmed in JavaScript/TypeScript before, but you ",(0,i.jsx)(n.strong,{children:"have"})," programmed in Lua, then this page is for you. Below, you can compare Lua code side by side with the equivalent TypeScript code. If you have coded a mod in Lua before, reading through this page will probably be enough to get you started."]}),"\n",(0,i.jsx)(n.p,{children:"If you have never programmed in Lua before, then this page will still be useful, but you can skip reading all of the Lua code blocks. (But it can't hurt to learn some Lua too. The best Isaac modders will fluently know both languages.)"}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h2,{id:"level-1---basic",children:"Level 1 - Basic"}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"comments",children:"Comments"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- This is a single-line comment in Lua.\n\n--[[\n\nThis is a multi-line comment in Lua.\nIt's very long.\nAnd wordy.\n\n--]]\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// This is a single-line comment in TypeScript.\n\n/*\n\nThis is a multi-line comment in TypeScript.\nIt's very long.\nAnd wordy.\n\n*/\n"})}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"semi-colons",children:"Semi-Colons"}),"\n",(0,i.jsx)(n.p,{children:"Unlike Lua, TypeScript code should have semi-colons after every line."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Lua code\nIsaac.DebugString("hello world")\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// TypeScript code\nIsaac.DebugString("hello world");\n'})}),"\n",(0,i.jsxs)(n.p,{children:["But don't bother typing the semi-colons yourself - just hit ",(0,i.jsx)(n.code,{children:"Ctrl + s"})," and the editor will automatically insert them for you. That's ",(0,i.jsx)(n.a,{href:"https://prettier.io/",children:"Prettier"})," doing its job."]}),"\n",(0,i.jsxs)(n.p,{children:["(In fact, you should always hit ",(0,i.jsx)(n.code,{children:"Ctrl + s"})," periodically as you code, so that the code is constantly formatting itself. This frees you from the tedium of aligning things, breaking up long if statements, and so forth. If the file is not auto-formatting itself, then you probably need to add a bracket somewhere so that the code can properly compile.)"]}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"colons",children:"Colons"}),"\n",(0,i.jsx)(n.p,{children:"In Lua, you sometimes call functions with a colon, and you sometimes call functions with a period. This is really annoying."}),"\n",(0,i.jsx)(n.p,{children:"In TypeScript, you call all functions with a period. Easy."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Lua code\nIsaac.DebugString("hello world")\nIsaac.GetPlayer():AddMaxHearts(2)\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// TypeScript code\nIsaac.DebugString("hello world");\nIsaac.GetPlayer().AddMaxHearts(2);\n'})}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsxs)(n.h3,{id:"variables-local--const-and-let",children:["Variables: ",(0,i.jsx)(n.code,{children:"local"})," \u279c ",(0,i.jsx)(n.code,{children:"const"})," and ",(0,i.jsx)(n.code,{children:"let"})]}),"\n",(0,i.jsxs)(n.p,{children:["In Lua, you type ",(0,i.jsx)(n.code,{children:"local"})," before declaring a variable to stop it from being turned into a global."]}),"\n",(0,i.jsx)(n.p,{children:"In TypeScript, this isn't necessary. There are no global variables, unless we explicitly decide to create one."}),"\n",(0,i.jsxs)(n.p,{children:["Furthermore, in TypeScript, there are two kinds of variable declarations: ",(0,i.jsx)(n.code,{children:"let"})," and ",(0,i.jsx)(n.code,{children:"const"}),".",(0,i.jsx)(n.br,{}),"\n(Don't ever use ",(0,i.jsx)(n.code,{children:"var"}),", which is only used in older JavaScript code.)"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Lua code\nlocal poop = "poop"\nlocal numFarts = 1\nnumFarts = numFarts + 1 -- numFarts is now equal to 2.\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// TypeScript code\nconst poop = "poop"; // We use "const" because this value never changes.\nlet numFarts = 1; // We use "let" because we have to modify it later.\nnumFarts = numFarts + 1; // numFarts is now equal to 2.\n'})}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"functions",children:"Functions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Lua code\nfunction getNumPoops() -- This is a global function.\n  return 2\nend\n\nlocal function getNumFarts() -- This is a local function.\n  return 3\nend\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// TypeScript code\n// All functions in TypeScript are local by default.\nfunction getNumPoops() {\n  return 2;\n}\n"})}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"anonymous-functions",children:"Anonymous Functions"}),"\n",(0,i.jsx)(n.p,{children:"For very small functions, it is common to type them anonymously (i.e. without a name)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Lua code\nmod:AddCallback(ModCallbacks.POST_NEW_LEVEL, function()\n  Isaac.DebugString("Arrived on a new floor.")\nend);\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// Typescript code\nmod.AddCallback(ModCallbacks.POST_NEW_LEVEL, () => {\n  Isaac.DebugString("Arrived on a new floor.");\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:"(If this syntax looks confusing, google \"JavaScript arrow functions\" in order to get more familiar with them. But of course, you don't have to use arrow functions if you don't want to.)"}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"arrays",children:"Arrays"}),"\n",(0,i.jsx)(n.p,{children:"An array is a data structure that is an ordered list of elements. In Lua, you use a table to represent an array."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'local myArray = {"foo", "bar", "baz"}\n'})}),"\n",(0,i.jsx)(n.p,{children:"In TypeScript, there is a dedicated syntax for arrays: the square brackets."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'const myArray = ["foo", "bar", "baz"];\n'})}),"\n",(0,i.jsx)(n.p,{children:"In Lua, there are two different ways to add an element to an array:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'table.insert(myArray, "someNewElement")\nmyArray[#myArray + 1] = "anotherNewElement"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In TypeScript, you use the ",(0,i.jsx)(n.code,{children:"push"})," method:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'myArray.push("someNewElement");\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In addition to ",(0,i.jsx)(n.code,{children:"push"}),", arrays have a lot of other handy methods that you can use. You can see all of them in ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",children:"the MDN docs"}),"."]}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"objects",children:"Objects"}),"\n",(0,i.jsx)(n.p,{children:"An object is a data structure that stores key/value pairs. In Lua, you use a table to represent an object. (An equal sign is used in between the keys and values.)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"local myObject = {\n  foo = 123,\n  bar = 456,\n  baz = 789,\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"In TypeScript, there is a dedicated syntax for objects: the curly brackets. (A colon is used in between the keys and the values.)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const myObject = {\n  foo: 123,\n  bar: 456,\n  baz: 789,\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"In Lua, there are two different ways to set an element:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'myObject.foo = 999\nmyObject["foo"] = 999\n'})}),"\n",(0,i.jsx)(n.p,{children:"In TypeScript, it is the exact same thing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'myObject.foo = 999;\nmyObject["foo"] = 999;\n'})}),"\n",(0,i.jsx)(n.p,{children:"(But ESLint will change the second form to the first form automatically when you save the file, so that everything remains consistent.)"}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsxs)(n.h3,{id:"if-statements-and-operators",children:[(0,i.jsx)(n.code,{children:"if"})," Statements and Operators"]}),"\n",(0,i.jsxs)(n.p,{children:["In Lua, you don't put parentheses around the conditions of an ",(0,i.jsx)(n.code,{children:"if"})," statement. But in TypeScript, you do."]}),"\n",(0,i.jsx)(n.p,{children:"Also, the operators are a bit different:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"and"})," \u279c ",(0,i.jsx)(n.code,{children:"&&"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"or"})," \u279c ",(0,i.jsx)(n.code,{children:"||"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"=="})," \u279c ",(0,i.jsx)(n.code,{children:"==="})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"~="})," \u279c ",(0,i.jsx)(n.code,{children:"!=="})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:".."})," \u279c ",(0,i.jsx)(n.code,{children:"+"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Lua code\nif x == 1 and y ~= 0 then\n  -- Do something.\nend\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// TypeScript code\nif (x === 1 && y !== 0) {\n  // Do something.\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If you find typing three equal signs annoying, then don't bother: if you type ",(0,i.jsx)(n.code,{children:"=="})," instead, ESLint will automatically convert it to ",(0,i.jsx)(n.code,{children:"==="})," when you save the file."]}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsxs)(n.h3,{id:"for-statements-for-counting",children:[(0,i.jsx)(n.code,{children:"for"})," Statements for Counting"]}),"\n",(0,i.jsxs)(n.p,{children:["In Lua, basic ",(0,i.jsx)(n.code,{children:"for"})," loops look like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Lua code\nfor i = 1, 10 do\n  -- "i" will iterate upwards from 1 to 10.\nend\n'})}),"\n",(0,i.jsx)(n.p,{children:"In TypeScript, you use the more-standard C-style syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// TypeScript code\nfor (let i = 1; i <= 10; i++) {\n  // "i" will iterate upwards from 1 to 10.\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Alternatively, you can use the ",(0,i.jsx)(n.code,{children:"iRange"})," helper function provided by the ",(0,i.jsx)(n.code,{children:"isaacscript-common"})," standard library. This allows the code to be a bit more safe & understandable:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// TypeScript code\nfor (const i of iRange(1, 10)) {\n  // "i" will iterate upwards from 1 to 10.\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"In Lua, you count downwards like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Lua code\nfor i = 10, 1, -1 do\n  -- "i" will iterate downwards from 10 to 1.\nend\n'})}),"\n",(0,i.jsx)(n.p,{children:"In TypeScript, that would be:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// TypeScript code\nfor (let i = 10; i >= 1; i--) {\n  // "i" will iterate downwards from 10 to 1.\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Or, with the ",(0,i.jsx)(n.code,{children:"iRange"})," helper function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// TypeScript code\nfor (const i of iRange(10, 1)) {\n  // "i" will iterate downwards from 10 to 1.\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Note that you can also use the ",(0,i.jsx)(n.code,{children:"eRange"})," helper function for an exclusive range (instead of an inclusive range)."]}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsxs)(n.h3,{id:"for-statements-for-arrays",children:[(0,i.jsx)(n.code,{children:"for"})," Statements for Arrays"]}),"\n",(0,i.jsxs)(n.p,{children:["In Lua, the typical way to iterate over an array is with ",(0,i.jsx)(n.code,{children:"ipairs"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Lua code\nlocal gapers = Isaac.FindByType(EntityType.ENTITY_GAPER)\n\nfor i, gaper in ipairs(gapers) do\n  gaper:Remove()\n  print("Removed gaper number:", i);\nend\n'})}),"\n",(0,i.jsx)(n.p,{children:"In TypeScript, you have a few different options."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// Typescript code\nconst gapers = Isaac.FindByType(EntityType.ENTITY_GAPER);\n\n// A "for of" loop is the simplest way to iterate over an array. It provides the array element.\nfor (const gaper of gapers) {\n  gaper.Remove();\n}\n\n// If you need the array index and the array element, use the `entries` method.\nfor (const [i, gaper] of gapers.entries()) {\n  gaper.Remove();\n  print("Removed gaper number:", i);\n}\n\n// If you just need the array index, use the `keys` method.\n// The keys start at 0, unlike Lua. (In Lua, array keys start at 1.)\nfor (const i of gapers.keys()) {\n  print("On gaper index:", i);\n}\n'})}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsxs)(n.h3,{id:"for-statements-for-keyvalue-tables",children:[(0,i.jsx)(n.code,{children:"for"})," Statements for Key/Value Tables"]}),"\n",(0,i.jsxs)(n.p,{children:["In Lua, the typical way to iterate over a key/value table is with ",(0,i.jsx)(n.code,{children:"pairs"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Lua code\n-- Define a table of collectible prices.\n-- (We must put "[]" around the collectible types since the table keys are numbers.)\nlocal collectiblePrices = {\n  [3] = 15, -- Spoon Bender is 15 coins.\n  [4] = 15, -- Cricket\'s Head is 15 coins.\n  [5] = 7, -- My Reflection is 7 coins.\n}\n\nfor collectibleType, price in pairs(collectiblePrices) do\n  -- Do something with "collectibleType" and "price".\nend\n'})}),"\n",(0,i.jsx)(n.p,{children:"In TypeScript, you have a few different options."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// TypeScript code\n// Define an object containing collectible prices.\nconst collectiblePrices = {\n  [3]: 15, // Spoon Bender is 15 coins.\n  [4]: 15, // Cricket\'s Head is 15 coins.\n  [5]: 7, // My Reflection is 7 coins.\n};\n\nfor (const [collectibleType, price] of Object.entries(collectiblePrices)) {\n  // Do something with "collectibleType" and "price".\n}\n\n// Or, if you just need the collectible type, you would use the "keys()" method.\nfor (const collectibleType of Object.keys(collectiblePrices)) {\n  // Do something with "collectibleType".\n}\n\n// Or, if you just need the price, you would use the "values()" method.\nfor (const price of Object.values(collectiblePrices)) {\n  // Do something with "price".\n}\n'})}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsxs)(n.h3,{id:"nil--undefined",children:[(0,i.jsx)(n.code,{children:"nil"})," \u279c ",(0,i.jsx)(n.code,{children:"undefined"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Lua code\nif entity.SpawnerEntity == nil then\n  -- This entity was not spawned by anything in particular.\nend\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// TypeScript code\nif (entity.SpawnerEntity === undefined) {\n  // This entity was not spawned by anything in particular.\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that ",(0,i.jsx)(n.code,{children:"null"})," also transpiles to ",(0,i.jsx)(n.code,{children:"nil"})," (in addition to ",(0,i.jsx)(n.code,{children:"undefined"}),"). In order to keep your code easy to read, never use ",(0,i.jsx)(n.code,{children:"null"})," unless you specifically want to model an actual null-type defined value."]}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h2,{id:"level-2---intermediate",children:"Level 2 - Intermediate"}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"assignment-operators",children:"Assignment Operators"}),"\n",(0,i.jsx)(n.p,{children:"Lua does not have assignment operators, because it is a terrible language."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Lua code\nlocal numFarts = 1\nnumFarts = numFarts + 1 -- numFarts is now equal to 2.\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// TypeScript code\nlet numFarts = 1;\nnumFarts += 1; // numFarts is now equal to 2.\n"})}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"increment-and-decrement-operators",children:"Increment and Decrement Operators"}),"\n",(0,i.jsx)(n.p,{children:"Lua does not have increment or decrement operators. Handily, TypeScript does."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Lua code\nlocal numFarts = 1\nnumFarts = numFarts + 1 -- numFarts is now equal to 2.\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// TypeScript code\nlet numFarts = 1;\nnumFarts++; // numFarts is now equal to 2.\n"})}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"string-concatenation",children:"String Concatenation"}),"\n",(0,i.jsx)(n.p,{children:"The way to concatenate strings is different:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Lua code\nlocal poopString = "Poop"\nlocal fartString = "Fart"\nlocal combinedString = poopString .. fartString -- combinedString is now equal to "PoopFart".\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// TypeScript code\nconst poopString = "Poop";\nconst fartString = "Fart";\nconst combinedString = poopString + fartString; // combinedString is now equal to "PoopFart".\n'})}),"\n",(0,i.jsx)(n.p,{children:"(Unlike Lua, TypeScript uses the same operator for adding numbers and concatenating strings.)"}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"string-conversion",children:"String Conversion"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Lua code\nlocal numPoops = 3\nlocal numPoopsString = tostring(numPoops)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// TypeScript code\nconst numPoops = 3;\nconst numPoopsString1 = tostring(numPoops); // You can do the same thing as you would in Lua.\nconst numPoopsString2 = numPoops.toString(); // Or, you can use the typical JavaScript conversion method.\n"})}),"\n",(0,i.jsx)(n.p,{children:"Feel free to use either the standard Lua method or the JavaScript conversion method - it will be transpiled to the same thing."}),"\n",(0,i.jsx)(n.p,{children:"Furthermore, when concatenating numbers to strings, TypeScript will automatically convert them to strings for you:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Lua code\nlocal numPoops = 3\nlocal numFarts = 4\nIsaac.DebugString("numPoops: " .. tostring(numPoops) .. ", numFarts: " .. tostring(numFarts))\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// Typescript code\nconst numPoops = 3;\nconst numFarts = 4;\nIsaac.DebugString("numPoops: " + numPoops + ", numFarts: " + numFarts); // No conversion necessary!\n'})}),"\n",(0,i.jsx)(n.h3,{id:"string-templates",children:"String Templates"}),"\n",(0,i.jsxs)(n.p,{children:["TypeScript has a special feature that Lua does not have called ",(0,i.jsx)(n.em,{children:"string templates"}),". String templates allow you to easily create a string that has a bunch of variables in it. They are denoted by the ",(0,i.jsx)(n.code,{children:"`"})," character."]}),"\n",(0,i.jsxs)(n.p,{children:["In the previous section, we used the ",(0,i.jsx)(n.code,{children:"+"})," operator to combine a bunch of variables with text. But it would be better written by using a string template, like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// Typescript code\nconst numPoops = 3;\nconst numFarts = 4;\nIsaac.DebugString(`numPoops: ${numPoops}, numFarts: ${numFarts}`);\n"})}),"\n",(0,i.jsx)(n.p,{children:"You will probably want to get in the habit of using string templates, since they end up making your code more concise and easier to read."}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"typescript-type-annotations",children:"TypeScript Type Annotations"}),"\n",(0,i.jsx)(n.p,{children:"The main thing that TypeScript adds to JavaScript is type annotations. Here's a quick example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Lua code\nfunction postPlayerInit(player)\n  player:AddCollectible(1, 0, false) -- Sad Onion\nend\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// JavaScript code\nfunction postPlayerInit(player) {\n  player.AddCollectible(1, 0, false); // Sad Onion\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// TypeScript code\nfunction postPlayerInit(player: EntityPlayer) {\n  player.AddCollectible(1, 0, false); // Sad Onion\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the TypeScript code snippet, you can see that we marked the ",(0,i.jsx)(n.code,{children:"player"})," function argument as the ",(0,i.jsx)(n.code,{children:"EntityPlayer"})," type by using a colon. The ",(0,i.jsx)(n.code,{children:"EntityPlayer"})," type is automatically provided by the ",(0,i.jsx)(n.code,{children:"isaac-typescript-definitions"})," package, and corresponds to ",(0,i.jsxs)(n.a,{href:"https://wofsauge.github.io/IsaacDocs/rep/EntityPlayer.html",children:[(0,i.jsx)(n.code,{children:"EntityPlayer"})," in the official docs"]}),". (The ",(0,i.jsx)(n.code,{children:"isaac-typescript-definitions"})," package is automatically added to any IsaacScript project.)"]}),"\n",(0,i.jsxs)(n.p,{children:["Once the type has been annotated, your editor will know about all of the legal methods for the ",(0,i.jsx)(n.code,{children:"player"})," variable. For example, if you make a typo on the ",(0,i.jsx)(n.code,{children:"AddCollectible"})," method, the editor will immediately tell you by drawing a red squiggly line underneath it."]}),"\n",(0,i.jsx)(n.p,{children:"When coding in TypeScript, you will need to add the type for every function argument. That way, the compiler can catch all of the bugs."}),"\n",(0,i.jsx)(n.p,{children:"(Note that if you are just trying out a new function, then you can quickly type it out without the types. The compiler will give errors, but you can ignore them and everything will work fine as you test the function in-game. Once you are satisfied with the function, you can go back and fill in the types.)"}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"type-inference-for-variables",children:"Type Inference For Variables"}),"\n",(0,i.jsx)(n.p,{children:"In the previous section, we provided a type annotation for a function argument (by using a colon). It is also possible to provide a type annotation for other things. For example, this is providing a type annotation for a variable declaration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const myNumber: number = 123;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Here, we are explicitly telling the compiler what the type of the variable is. But in this case, doing this is redundant. The type is obviously a number, because 123 is a number. So we can just type out the variable like normal:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const myNumber = 123;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, TypeScript will infer that ",(0,i.jsx)(n.code,{children:"myNumber"})," is of type ",(0,i.jsx)(n.code,{children:"number"}),", because it knows that 123 is a number. This is called ",(0,i.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/handbook/type-inference.html",children:"type inference"}),". So, in general, we should never explicitly put the types on variables when they can be inferred, because it adds useless noise to the code. In this way, TypeScript saves a ton of time over older programming languages like Java. (In Java, you have to type out the type for every single variable, which is a pain.)"]}),"\n",(0,i.jsx)(n.p,{children:"However, in some cases, we do need to specify what the type of the variable is. Imagine that we are creating a new array that will contain numbers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// We will add some numbers types later on, but right now we just need to initialize the array.\nconst numberArray = [];\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, TypeScript is able to infer that the type of the variable is an array. But it can't infer what is supposed to go inside of the array, for obvious reasons. So the type defaults to ",(0,i.jsx)(n.code,{children:"any[]"}),' (which means "an array containing anything").']}),"\n",(0,i.jsx)(n.p,{children:"This is bad, because we want our arrays to be type safe. Thus, when we declare arrays (and other container-like objects), we have to tell TypeScript what kinds of things they should contain:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const numberArray: number[] = [];\n"})}),"\n",(0,i.jsx)(n.p,{children:"Much better!"}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"type-inference-for-functions",children:"Type Inference For Functions"}),"\n",(0,i.jsx)(n.p,{children:"You can also use type annotations to specify the return type of a function, like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// The return type is "boolean".\nfunction isEven(num: number): boolean {\n  return num % 2 === 0;\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Here, providing the return type annotation is optional. If we don't specify it, the compiler would infer what the return type is automatically, saving us the time from having to type it out."}),"\n",(0,i.jsxs)(n.p,{children:["With that said, just because we don't ",(0,i.jsx)(n.em,{children:"have"})," to type it does not mean that we should ",(0,i.jsx)(n.em,{children:"never"})," type it. Having return type annotations on functions is often pretty useful, as it can catch bugs when you accidentally return things that you did not intend."]}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"void",children:"Void"}),"\n",(0,i.jsxs)(n.p,{children:["If a function is not expected to return anything, then the return type is ",(0,i.jsx)(n.code,{children:"void"}),". For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function addSadOnion(player: EntityPlayer): void {\n  player.AddCollectible(1); // Sad Onion\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"But annotating a return type of void is pretty pointless, so the function is better written without the return type annotation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function addSadOnion(player: EntityPlayer) {\n  player.AddCollectible(1); // Sad Onion\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"One exception is when the function is exported. (More on what exported functions are later.) By default, the IsaacScript linter is configured to require return types for all exported functions. So, if the previous function was exported, you would write it like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export function addSadOnion(player: EntityPlayer): void {\n  player.AddCollectible(1); // Sad Onion\n}\n"})}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsxs)(n.h3,{id:"splitting-your-code-into-multiple-files-require--import",children:["Splitting Your Code Into Multiple Files: ",(0,i.jsx)(n.code,{children:"require()"})," \u279c ",(0,i.jsx)(n.code,{children:"import"})]}),"\n",(0,i.jsxs)(n.p,{children:["In Lua, you split your code into multiple files by using ",(0,i.jsx)(n.code,{children:"require()"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"mainlua",children:(0,i.jsx)(n.code,{children:"main.lua"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- In Lua, we must namespace the mod\'s Lua files in a directory of the same name to avoid require\n-- conflicts.\nlocal postGameStarted = require("revelations.callbacks.postGameStarted")\n\nlocal mod = RegisterMod("Revelations", 1)\npostGameStarted:init(mod)\n'})}),"\n",(0,i.jsx)(n.h4,{id:"revelationscallbackspostgamestartedlua",children:(0,i.jsx)(n.code,{children:"revelations/callbacks/postGameStarted.lua"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local postGameStarted = {}\n\nfunction postGameStarted:init(mod)\n  mod:AddCallback(ModCallbacks.POST_GAME_STARTED, postGameStarted.main);\nend\n\nfunction postGameStarted:main()\n  local player = Isaac.GetPlayer()\n  player:AddCollectible(1, 0, false) -- Sad Onion\nend\n\nreturn postGameStarted\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In TypeScript, this is accomplished with ",(0,i.jsx)(n.code,{children:"import"}),".",(0,i.jsx)(n.br,{}),"\n(Don't ever use the JavaScript/TypeScript version of ",(0,i.jsx)(n.code,{children:"require()"}),", which is only used in older JavaScript code.)"]}),"\n",(0,i.jsx)(n.h4,{id:"maints",children:(0,i.jsx)(n.code,{children:"main.ts"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'import { postGameStartedInit } from "./callbacks/postGameStarted";\n\nconst mod = RegisterMod("Revelations", 1);\npostGameStartedInit(mod);\n'})}),"\n",(0,i.jsx)(n.h4,{id:"callbackspostgamestartedts",children:(0,i.jsx)(n.code,{children:"callbacks/postGameStarted.ts"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// "export" makes it so that other files can use this function.\nexport function postGameStartedInit(mod: Mod): void {\n  mod.AddCallback(ModCallbacks.POST_GAME_STARTED, main);\n}\n\nfunction main() {\n  const player = Isaac.GetPlayer();\n  player.AddCollectible(1, 0, false); // Sad Onion\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"(With TypeScript, there is no need to have a superfluous namespacing directory like in Lua.)"}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h2,{id:"level-3---advanced",children:"Level 3 - Advanced"}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"using-global-variables",children:"Using Global Variables"}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes, your mod might need to use a global variable exported by someone else's mod. For example, you might need to use the ",(0,i.jsx)(n.code,{children:"InfinityTrueCoopInterface"})," global variable from the True Co-op Mod. (This mod is useless now in Repentance, but in Afterbirth+, most character mods would want to register their character with the True Co-op Mod.)"]}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h4,{id:"option-1---inline-declarations",children:"Option 1 - Inline Declarations"}),"\n",(0,i.jsx)(n.p,{children:"In Lua, checking to see if the user has the True Co-op Mod installed would look something like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Lua code\nif InfinityTrueCoopInterface ~= nil then\n  -- The user has the True Co-op mod enabled, so now do something.\nend\n"})}),"\n",(0,i.jsx)(n.p,{children:"The TypeScript equivalent would look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// TypeScript code\nif (InfinityTrueCoopInterface !== undefined) {\n  // The user has the True Co-op mod enabled, so now do something.\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:['However, this exact code would result in an error, because the TypeScript compiler (rightly) complains that the "InfinityTrueCoopInterface" variable does not exist. Normally, this kind of thing is extremely useful, because when a variable "does not exist", it usually means we forgot to initialize it or we made a typo somewhere. However, in this case, the "InfinityTrueCoopInterface" variable really does exist - it\'s just not a part of ',(0,i.jsx)(n.em,{children:"our"})," code. So, we just need a way to tell the TypeScript compiler that."]}),"\n",(0,i.jsxs)(n.p,{children:["The way to do that is to use the ",(0,i.jsx)(n.code,{children:"declare"})," keyword, like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// TypeScript code\ndeclare const InfinityTrueCoopInterface: unknown | undefined;\n\nif (InfinityTrueCoopInterface !== undefined) {\n  // The user has the True Co-op mod enabled, so now do something.\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"declare"}),' keyword essentially means "the following variable exists outside of the context of this program, and is provided by some other running code". Importantly, ',(0,i.jsx)(n.code,{children:"declare"})," statements do not actually result in any transpiled Lua code; they are purely messages to the TypeScript compiler."]}),"\n",(0,i.jsxs)(n.p,{children:["In this context, we annotate the type of the variable as ",(0,i.jsx)(n.code,{children:"unknown | undefined"}),', which means that it is either "something" or "does not exist". (',(0,i.jsx)(n.code,{children:"unknown"})," is a special TypeScript type that you can use when you don't know what the real type of something is.)"]}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h4,{id:"option-2---a-declaration-file",children:"Option 2 - A Declaration File"}),"\n",(0,i.jsxs)(n.p,{children:["If you check for ",(0,i.jsx)(n.code,{children:"InfinityTrueCoopInterface !== undefined"})," in more than one place in your mod, then option 1 is bad, because you would be ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself",children:"need to repeat yourself before each check"}),". Instead, make a TypeScript definition file that corresponds to the variable / table."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, to declare ",(0,i.jsx)(n.code,{children:"InfinityTrueCoopInterface"}),", starting from the root of your project:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Create the ",(0,i.jsx)(n.code,{children:"src/types"})," directory."]}),"\n",(0,i.jsxs)(n.li,{children:["Create the ",(0,i.jsx)(n.code,{children:"src/types/InfinityTrueCoopInterface.d.ts"})," file. (A ",(0,i.jsx)(n.code,{children:"d.ts"})," file is a TypeScript ",(0,i.jsx)(n.em,{children:"declaration"})," file.)"]}),"\n",(0,i.jsx)(n.li,{children:"Put the following in it:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"declare const InfinityTrueCoopInterface: unknown | undefined;\n"})}),"\n",(0,i.jsx)(n.p,{children:'Now, your other TypeScript files will "see" it as a global variable without you having to do anything else.'}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"creating-global-variables",children:"Creating Global Variables"}),"\n",(0,i.jsx)(n.p,{children:"In Lua, some mods export functionality by using a global variable:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- Lua code\nRevelationsVersion = "2.1"\n-- "RevelationsVersion" is now a global variable.\n'})}),"\n",(0,i.jsx)(n.p,{children:"In TypeScript, you just have to declare it beforehand:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// TypeScript code\ndeclare let RevelationsVersion: string;\nRevelationsVersion = "2.1";\n// "RevelationsVersion" is now a global variable.\n'})}),"\n",(0,i.jsx)(n.p,{children:"Building on this example, you can also expose both variables and methods:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'declare let RevelationsExports: unknown;\nRevelationsExports = {\n  myVariable1,\n  myVariable2,\n  myFunction1,\n  myFunction2,\n};\n// "RevelationsExports" is now a global variable.\n'})}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"enums",children:"Enums"}),"\n",(0,i.jsxs)(n.p,{children:["In the previous ",(0,i.jsxs)(n.a,{href:"#for-statements-for-keyvalue-tables",children:[(0,i.jsx)(n.code,{children:"for"})," loop section"]}),", we defined a mapping of collectibles to prices."]}),"\n",(0,i.jsx)(n.p,{children:"Imagine that in our mod, collectibles can only be sold for three different prices:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"15 coins (normal)"}),"\n",(0,i.jsx)(n.li,{children:"30 coins (double)"}),"\n",(0,i.jsx)(n.li,{children:"7 coins (on sale)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This means that we can get even more specific with our collectible prices definition by using an ",(0,i.jsx)(n.code,{children:"enum"}),". Unlike Lua, TypeScript has a built-in ",(0,i.jsx)(n.code,{children:"enum"})," data type."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"enum CollectiblePrice {\n  NORMAL = 15,\n  DOUBLE = 30,\n  SALE = 7,\n}\n\n// collectiblePrices now only has values of CollectiblePrice, which is even safer than before!\nconst collectiblePrices = {\n  [3: CollectiblePrice.NORMAL, // Spoon Bender\n  [4]: CollectiblePrice.NORMAL, // Cricket's Head\n  [5]: CollectiblePrice.SALE, // My Reflection\n};\n"})}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"maps",children:"Maps"}),"\n",(0,i.jsxs)(n.p,{children:["In the previous ",(0,i.jsx)(n.a,{href:"#enums",children:"enums"})," section, we defined ",(0,i.jsx)(n.code,{children:"collectiblePrices"})," as an object, which is roughly equivalent to a Lua table."]}),"\n",(0,i.jsxs)(n.p,{children:["Objects are good for cases where every possibility is accounted for. But this isn't the case for ",(0,i.jsx)(n.code,{children:"collectiblePrices"}),". Here, we are only specifying the prices for ",(0,i.jsx)(n.em,{children:"some"})," of the collectibles in the game. If a collectible isn't in the list, we'll probably want to ignore it, or give it a default value, or something along those lines."]}),"\n",(0,i.jsxs)(n.p,{children:["In this example, what ",(0,i.jsx)(n.code,{children:"collectiblePrices"})," ",(0,i.jsx)(n.em,{children:"really"})," represents is a ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Associative_array",children:(0,i.jsx)(n.em,{children:"map"})})," of a specific collectible type to a price. Unlike Lua, TypeScript has a built-in ",(0,i.jsx)(n.code,{children:"Map"})," data type. So, the example would be better written like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'const collectiblePrices = new Map<number, CollectiblePrice>([\n  [3, CollectiblePrice.NORMAL], // Spoon Bender\n  [4, CollectiblePrice.NORMAL], // Cricket\'s Head\n  [5, CollectiblePrice.SALE], // My Reflection\n]);\n\nfor (const [collectibleType, price] of collectiblePrices.entries()) {\n  // Do something with "collectibleType" and "price".\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, ",(0,i.jsx)(n.code,{children:"collectiblePrices"})," has a type of ",(0,i.jsx)(n.code,{children:"Map<number, CollectiblePrice>"}),", which is more specific than an untyped object."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The first value in the angle brackets corresponds to the map key type."}),"\n",(0,i.jsx)(n.li,{children:"The second value in the angle brackets corresponds to the map value type."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["We initialize the map by passing an array of key/value pairs to the constructor. (Alternatively, we could start the map empty and then use the ",(0,i.jsx)(n.code,{children:"set"})," method to set some values later on.)"]}),"\n",(0,i.jsxs)(n.p,{children:["With a map, you can use all of the handy methods ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",children:"shown in the MDN docs"})," (listed on the left side). Here's an example of using the ",(0,i.jsx)(n.code,{children:"get"})," method to emulate checking for a value in a Lua table:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Lua code\nfunction pickingUpCollectible(player, collectibleType)\n  -- If the player picked up a new collectible,\n  -- subtract the price of that collectible from their coin amount.\n  local price = collectiblePrices[collectibleType]\n  if price ~= nil then\n    player:AddCoins(price * -1)\n  end\nend\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// TypeScript code\nfunction pickingUpCollectible(player: EntityPlayer, collectibleType: int) {\n  // If the player picked up a new collectible,\n  // subtract the price of that collectible from their coin amount.\n  const price = collectiblePrices.get(collectibleType);\n  if (price !== undefined) {\n    player.AddCoins(price * -1);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.h3,{id:"type-narrowing",children:"Type Narrowing"}),"\n",(0,i.jsx)(n.p,{children:"Lua allows you to write unsafe code. Consider the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Lua code\nlocal player = entity:ToPlayer() -- Convert the entity to a player.\nplayer:AddMaxHearts(2) -- Give them a heart container.\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Not all entities convert to players though, so this code can fail. In fact, for most entities, the ",(0,i.jsx)(n.code,{children:"ToPlayer"})," method would return ",(0,i.jsx)(n.code,{children:"nil"})," and cause the next line to throw a run-time error, preventing all of the subsequent code in the callback from firing. In TypeScript, writing this code would cause a compiler error:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const player = entity.ToPlayer();\nplayer.AddMaxHearts(2); // Error: Object is possibly 'undefined'\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This error is because the return type of the ",(0,i.jsx)(n.code,{children:"ToPlayer()"})," method is ",(0,i.jsx)(n.code,{children:"EntityPlayer | undefined"}),' (which means "either an ',(0,i.jsx)(n.code,{children:"EntityPlayer"}),' or nothing"). To solve this error, we can use ',(0,i.jsx)(n.em,{children:"type narrowing"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'const player = entity.ToPlayer();\nif (player === undefined) {\n  error("Failed to convert the entity to a player.");\n}\nplayer.AddMaxHearts(2); // The type of player is now narrowed to "EntityPlayer".\n'})}),"\n",(0,i.jsx)(n.p,{children:"Here, we explicitly handle the error case and supply a helpful error message. But this code does something more important than simply providing the error message."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"error"})," is a Lua function that causes execution of the function to immediately end. Thus, TypeScript is smart enough to realize that if the code gets to the ",(0,i.jsx)(n.code,{children:"AddMaxHearts"})," line, the type of ",(0,i.jsx)(n.code,{children:"player"})," is no longer ",(0,i.jsx)(n.code,{children:"EntityPlayer | undefined"})," - it would have to be a ",(0,i.jsx)(n.code,{children:"EntityPlayer"}),". You can confirm this by mousing over the variable in VSCode."]}),"\n",(0,i.jsxs)(n.p,{children:["Since many of the Isaac API methods can fail, you will have to use ",(0,i.jsx)(n.em,{children:"type narrowing"})," like this in many places in your code. Sometimes, it can be annoying to explicitly check to see if things go wrong. But ",(0,i.jsx)(n.em,{children:"type narrowing"})," should be seen as a good thing: by handling errors in a sane way, you safely compartmentalize the damage that run-time errors can cause. And when things do go wrong, troubleshooting what happened becomes a lot easier."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var i=t(14041);const a={},o=i.createContext(a);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);