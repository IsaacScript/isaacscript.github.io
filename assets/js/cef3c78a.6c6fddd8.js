"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[16289],{88375:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>r});var s=n(31085),i=n(71184);const o={title:"The Difference Between Enums and Objects"},l=void 0,a={id:"main/enums-and-objects",title:"The Difference Between Enums and Objects",description:"In IsaacScript mods, both enums and objects are used, depending on the situation. This might be a little confusing.",source:"@site/docs/main/enums-and-objects.md",sourceDirName:"main",slug:"/main/enums-and-objects",permalink:"/main/enums-and-objects",draft:!1,unlisted:!1,editUrl:"https://github.com/IsaacScript/isaacscript/edit/main/packages/docs/docs/main/enums-and-objects.md",tags:[],version:"current",frontMatter:{title:"The Difference Between Enums and Objects"},sidebar:"docs",previous:{title:"Using Entity.GetData and the Save Data Manager",permalink:"/main/using-get-data"},next:{title:"Using Feature Classes - The Modern Way to Write Isaac Mods",permalink:"/main/mod-feature"}},c={},r=[{value:"Enum Introduction",id:"enum-introduction",level:3},{value:"Enums By Default",id:"enums-by-default",level:3},{value:"1) Clear Intent",id:"1-clear-intent",level:4},{value:"2) Computed Members",id:"2-computed-members",level:4},{value:"3) Reverse Mapping",id:"3-reverse-mapping",level:4},{value:"Conclusion - Use Enums",id:"conclusion---use-enums",level:4},{value:"The Differences Between Types and Containers",id:"the-differences-between-types-and-containers",level:3},{value:"1) The <code>CollectibleType</code> Type",id:"1-the-collectibletype-type",level:4},{value:"2) The <code>CollectibleType</code> Container",id:"2-the-collectibletype-container",level:4},{value:"The Differences Between Objects and Enums",id:"the-differences-between-objects-and-enums",level:3},{value:"Where Enums Don&#39;t Work",id:"where-enums-dont-work",level:3}];function d(e){const t={a:"a",blockquote:"blockquote",br:"br",code:"code",em:"em",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"In IsaacScript mods, both enums and objects are used, depending on the situation. This might be a little confusing."}),"\n",(0,s.jsx)(t.p,{children:"For most purposes, it is not important to know the low-level details - you can use whichever one you like. But if you want to dive into some of the details and explore the differences, then read on."}),"\n",(0,s.jsx)(t.br,{}),"\n",(0,s.jsx)(t.h3,{id:"enum-introduction",children:"Enum Introduction"}),"\n",(0,s.jsx)(t.p,{children:'"Enum" is short for "enumeration". In programming, the term is used to describe an object that contains a finite set of values.'}),"\n",(0,s.jsxs)(t.p,{children:["TypeScript has first-class support for enums. This means that you can type the word ",(0,s.jsx)(t.code,{children:"enum"})," to create one, and this is part of the language itself, which is really handy. In good code, enums are used a lot: they get rid of ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Magic_number_(programming)",children:"magic numbers"})," and constrain possible values to a finite set."]}),"\n",(0,s.jsx)(t.p,{children:"For example, this is the enum that describes the four different kinds of slots that active items can go into:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"enum ActiveSlot {\n  PRIMARY = 0,\n  SECONDARY = 1,\n  POCKET = 2,\n  POCKET_SINGLE_USE = 3,\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"But notice that we could also type this as an object instead:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const ActiveSlot = {\n  PRIMARY: 0,\n  SECONDARY: 1,\n  POCKET: 2,\n  POCKET_SINGLE_USE: 3,\n};\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This is ",(0,s.jsx)(t.em,{children:"kind of"})," the same thing, but there are a few key differences."]}),"\n",(0,s.jsx)(t.br,{}),"\n",(0,s.jsx)(t.h3,{id:"enums-by-default",children:"Enums By Default"}),"\n",(0,s.jsx)(t.p,{children:"Let's start with the basics. By default, we should use enums over objects, where possible. Why?"}),"\n",(0,s.jsx)(t.h4,{id:"1-clear-intent",children:"1) Clear Intent"}),"\n",(0,s.jsxs)(t.p,{children:['First, enums make the intent more clear. Enums represent the concept of "a finite set of values". On the other hand, a plain object can represent basically anything. If we want to specify a finite set of values, then using an ',(0,s.jsx)(t.code,{children:"enum"})," clearly communicates the intent to anyone reading the code."]}),"\n",(0,s.jsx)(t.h4,{id:"2-computed-members",children:"2) Computed Members"}),"\n",(0,s.jsxs)(t.p,{children:["Second, enums have a feature called ",(0,s.jsx)(t.a,{href:"https://www.typescriptlang.org/docs/handbook/enums.html#computed-and-constant-members",children:"computed members"}),". This means that we don't have to bother typing out what the values are. For example, we can type the ",(0,s.jsx)(t.code,{children:"ActiveSlot"})," enum from earlier like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"enum ActiveSlot {\n  PRIMARY,\n  SECONDARY,\n  POCKET,\n  POCKET_SINGLE_USE,\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Here, TypeScript automatically assigns a value of 0 to the first member, a value of 1 to the second member, and so on. This saves time ",(0,s.jsx)(t.em,{children:"now"}),", because we don't have to type ",(0,s.jsx)(t.code,{children:"= 0"})," (and so on). It also saves time ",(0,s.jsx)(t.em,{children:"later"}),", because if we add a new entry in the middle, we don't have to also modify all the lines that come afterwards."]}),"\n",(0,s.jsx)(t.h4,{id:"3-reverse-mapping",children:"3) Reverse Mapping"}),"\n",(0,s.jsxs)(t.p,{children:["Third, enums automatically get a reverse mapping at run-time. For example, imagine that you are debugging something to do the ",(0,s.jsx)(t.code,{children:"ActiveSlot"})," enum above. You might type the following code to help troubleshoot it:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"log(`DEBUG - The active slot is: ${activeSlot}`);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This might print out: ",(0,s.jsx)(t.code,{children:"DEBUG - The active slot is: 2"}),". But that's annoying, because we might not know what 2 even means in this context. Instead, we can make life easier on ourselves by writing our debug statement like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"log(`DEBUG - The active slot is: ${ActiveSlot[activeSlot]} (${activeSlot})`);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This would print out: ",(0,s.jsx)(t.code,{children:"DEBUG - The active slot is: POCKET (2)"}),". Much better! In essence, the reverse mapping helps us easily retrieve the name of any enum value when we need it. (The lookup is done in O(1) time. On an object, it would be done in O(N) time, since we would have to iterate over the entries.)"]}),"\n",(0,s.jsx)(t.h4,{id:"conclusion---use-enums",children:"Conclusion - Use Enums"}),"\n",(0,s.jsx)(t.p,{children:'Thus, in the general case, we use enums. We only have to resort to using objects in the special cases where "normal" enums won\'t work.'}),"\n",(0,s.jsx)(t.br,{}),"\n",(0,s.jsx)(t.h3,{id:"the-differences-between-types-and-containers",children:"The Differences Between Types and Containers"}),"\n",(0,s.jsx)(t.p,{children:'So, what are the situations where "normal" enums won\'t work?'}),"\n",(0,s.jsx)(t.p,{children:'In order to understand that, we first have to understand the difference between a "type" and a "container". Enums blur the distinction between these two things, so we need to take a step back and think about how they can be different.'}),"\n",(0,s.jsxs)(t.h4,{id:"1-the-collectibletype-type",children:["1) The ",(0,s.jsx)(t.code,{children:"CollectibleType"})," Type"]}),"\n",(0,s.jsxs)(t.p,{children:['First, let\'s drill down on what exactly a "type" is. Consider the ',(0,s.jsx)(t.code,{children:"EntityPlayer.AddCollectible"})," method. You can use it like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const player = Isaac.GetPlayer();\nplayer.AddCollectible(CollectibleType.SAD_ONION);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"EntityPlayer.AddCollectible"})," method takes in a variable of type ",(0,s.jsx)(t.code,{children:"CollectibleType"}),". But notice that the following code will also work just fine:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'const MY_CUSTOM_ITEM = Isaac.GetItemIdByName("My Custom Item");\nconst player = Isaac.GetPlayer();\nplayer.AddCollectible(MY_CUSTOM_ITEM);\n'})}),"\n",(0,s.jsxs)(t.p,{children:["This is because the return type of the ",(0,s.jsx)(t.code,{children:"Isaac.GetItemIdByName"})," method is ",(0,s.jsx)(t.code,{children:"CollectibleType"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The point of this example is to show that ",(0,s.jsx)(t.em,{children:"any"})," variable can be of type ",(0,s.jsx)(t.code,{children:"CollectibleType"}),". As far as the ",(0,s.jsx)(t.code,{children:"EntityPlayer.AddCollectible"})," method is concerned, the requirement is ",(0,s.jsx)(t.strong,{children:"not"})," that the incoming thing is attached to the ",(0,s.jsx)(t.code,{children:"CollectibleType"})," enum, like ",(0,s.jsx)(t.code,{children:"CollectibleType.SAD_ONION"})," is. Rather, the requirement is that the type of the variable matches the ",(0,s.jsx)(t.code,{children:"CollectibleType"})," type."]}),"\n",(0,s.jsxs)(t.p,{children:["So, in most cases, we use the word ",(0,s.jsx)(t.code,{children:"CollectibleType"})," to refer to the ",(0,s.jsx)(t.code,{children:"CollectibleType"})," type. But that's not all we use it for."]}),"\n",(0,s.jsxs)(t.h4,{id:"2-the-collectibletype-container",children:["2) The ",(0,s.jsx)(t.code,{children:"CollectibleType"})," Container"]}),"\n",(0,s.jsxs)(t.p,{children:["We also use the word ",(0,s.jsx)(t.code,{children:"CollectibleType"}),' to refer to the "container" that holds all of the ',(0,s.jsx)(t.code,{children:"CollectibleType"})," values. To illustrate this, we could create a container with a different name, but still having ",(0,s.jsx)(t.code,{children:"CollectibleType"})," values:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const MyContainer = {\n  VALUE_1: CollectibleType.SAD_ONION,\n  VALUE_2: CollectibleType.INNER_EYE,\n  VALUE_3: CollectibleType.SPOON_BENDER,\n};\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Here, ",(0,s.jsx)(t.code,{children:"MyContainer"})," is not a type. It's just a container that holds values with the ",(0,s.jsx)(t.code,{children:"CollectibleType"})," type. We can use these values without a problem:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const player = Isaac.GetPlayer();\nplayer.AddCollectible(MyContainer.VALUE_1);\n"})}),"\n",(0,s.jsx)(t.h3,{id:"the-differences-between-objects-and-enums",children:"The Differences Between Objects and Enums"}),"\n",(0,s.jsx)(t.p,{children:"With the previous section in mind, we now know the main difference between an object and an enum:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Creating an object is just creating a container."}),"\n",(0,s.jsxs)(t.li,{children:["Creating an enum is creating both a container ",(0,s.jsx)(t.strong,{children:"and"})," a type at the same time, with all of the values inside of it automatically being converted to the new type."]}),"\n"]}),"\n",(0,s.jsx)(t.br,{}),"\n",(0,s.jsx)(t.h3,{id:"where-enums-dont-work",children:"Where Enums Don't Work"}),"\n",(0,s.jsx)(t.p,{children:"Now that we know the difference between objects and enums, we can explore the specific situations in which enums won't work. The most common situation is when we want to create an enum containing our modded items or entities."}),"\n",(0,s.jsx)(t.p,{children:'For example, imagine that we had a custom collectible in our mod called "Foo". Try typing the following into your mod:'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'enum CollectibleTypeCustom {\n  FOO = Isaac.GetItemIdByName("Foo"),\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"This will give an error:"}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"Type 'import(\"C:/Repositories/my-mod/node_modules/isaac-typescript-definitions/dist/enums/collections/subTypes\").CollectibleType' is not assignable to type 'CollectibleTypeCustom'."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["If we had typed ",(0,s.jsx)(t.code,{children:"FOO = 1"}),' or something like that, then under the hood, TypeScript would automatically convert "1" to a type of ',(0,s.jsx)(t.code,{children:"CollectibleTypeCustom"}),", and we wouldn't get an error. But since we used the ",(0,s.jsx)(t.code,{children:"Isaac.GetItemIdByName"})," method, the value is a ",(0,s.jsx)(t.code,{children:"CollectibleType"}),", which is more specific than a ",(0,s.jsx)(t.code,{children:"number"}),". TypeScript can't automatically convert ",(0,s.jsx)(t.code,{children:"CollectibleType"})," to ",(0,s.jsx)(t.code,{children:"CollectibleTypeCustom"}),", so it throws an error. (In TypeScript, the only supported types that you can feed to an enum for auto-conversion are ",(0,s.jsx)(t.code,{children:"number"})," or ",(0,s.jsx)(t.code,{children:"string"}),".)"]}),"\n",(0,s.jsx)(t.p,{children:"We could temporarily fix the problem by using a type assertion, like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'enum CollectibleTypeCustom {\n  FOO = Isaac.GetItemIdByName("Foo") as number,\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["This is essentially telling the TypeScript compiler: \"Hey, I'm positive this is a ",(0,s.jsx)(t.code,{children:"number"}),', so forget whatever else you think you know about this line." Doing that would make TypeScript succeed in converting the result of the method to the ',(0,s.jsx)(t.code,{children:"CollectibleTypeCustom"})," type. However, this isn't really what we want either. For example, say that later on, we want to give the player our custom collectible:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const player = Isaac.GetPlayer();\nplayer.AddCollectible(CollectibleTypeCustom.FOO);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This would give a compiler error, because ",(0,s.jsx)(t.code,{children:"CollectibleTypeCustom.FOO"})," is of type ",(0,s.jsx)(t.code,{children:"CollectibleTypeCustom"}),". And as we said earlier, the ",(0,s.jsx)(t.code,{children:"EntityPlayer.AddCollectible"})," method needs to take in a type of ",(0,s.jsx)(t.code,{children:"CollectibleType"}),", not ",(0,s.jsx)(t.code,{children:"CollectibleTypeCustom"}),". They are completely different types."]}),"\n",(0,s.jsx)(t.p,{children:'By now, hopefully it is clear that we do not want to actually create a new type (which is what making a new enum will do). Instead, what we really want to do is to create a new container that holds values of an existing type. So that\'s why the correct solution is to create a "pseudo-enum" object, like this:'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'const CollectibleTypeCustom = {\n  FOO: Isaac.GetItemIdByName("Foo"),\n};\n'})}),"\n",(0,s.jsxs)(t.p,{children:['We can use this pattern whenever we want to create a custom enum that "inherits" the type of an existing enum. For most intents and purposes, these "container" objects will work in the same way as a normal enum. (But note that they won\'t have a ',(0,s.jsx)(t.a,{href:"#3-reverse-mapping",children:"reverse mapping"})," embedded into them.)"]}),"\n",(0,s.jsx)(t.br,{})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},71184:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>a});var s=n(14041);const i={},o=s.createContext(i);function l(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);