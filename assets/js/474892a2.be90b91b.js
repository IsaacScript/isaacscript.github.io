"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[52636],{45339:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var n=a(31085),o=a(71184);const s={title:"Using Feature Classes - The Modern Way to Write Isaac Mods"},i=void 0,r={id:"main/mod-feature",title:"Using Feature Classes - The Modern Way to Write Isaac Mods",description:"The Problem",source:"@site/docs/main/mod-feature.md",sourceDirName:"main",slug:"/main/mod-feature",permalink:"/main/mod-feature",draft:!1,unlisted:!1,editUrl:"https://github.com/IsaacScript/isaacscript/edit/main/packages/docs/docs/main/mod-feature.md",tags:[],version:"current",frontMatter:{title:"Using Feature Classes - The Modern Way to Write Isaac Mods"},sidebar:"docs",previous:{title:"The Difference Between Enums and Objects",permalink:"/main/enums-and-objects"},next:{title:"Converting Lua Code",permalink:"/main/converting-lua-code"}},l={},c=[{value:"The Problem",id:"the-problem",level:2},{value:"The Benefits of Feature Classes",id:"the-benefits-of-feature-classes",level:2},{value:"Example",id:"example",level:2},{value:"Other <code>ModFeature</code> Features",id:"other-modfeature-features",level:2},{value:"Decorators",id:"decorators",level:3},{value:"Using <code>shouldCallbackMethodsFire</code> For Conditional Firing",id:"using-shouldcallbackmethodsfire-for-conditional-firing",level:3},{value:"Delayed Initialization",id:"delayed-initialization",level:3}];function d(e){const t={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"the-problem",children:"The Problem"}),"\n",(0,n.jsx)(t.p,{children:"As your mod grows bigger, organization becomes more important: nobody wants to work in a pigsty."}),"\n",(0,n.jsxs)(t.p,{children:["Most people already understand the basics: split code up into separate files. For example, it makes sense for a mod pack that contains 10 items to have all of the code for each individual item live in a file dedicated to just that item. That way, you can leverage the ",(0,n.jsx)(t.code,{children:"Ctrl + p"}),' hotkey in VSCode to jump to the exact spot that you need to go. And if you need to fix a bug with item 1, then you don\'t have to go on a scavenger hunt throughout the entire repository - you can just focus all of your attention on the file called "item1.ts".']}),"\n",(0,n.jsx)(t.p,{children:'But beyond the basics of "split code up into separate files", things get more tricky. What is the best way to organize a big Isaac mod with lots of features? (In this context, a "feature" refers to a new item, a new enemy, and so on.)'}),"\n",(0,n.jsx)(t.br,{}),"\n",(0,n.jsx)(t.h2,{id:"the-benefits-of-feature-classes",children:"The Benefits of Feature Classes"}),"\n",(0,n.jsx)(t.p,{children:"Historically, Isaac mods have subscribed feature functions to callbacks directly in the same file, and then imported the feature files from the main file. However, importing files for side effects like this can lead to spaghetti code. So, other mods unify callback logic into a single file per callback, and then have the callback files call the individual feature functions. Both of these mod organization strategies have pros and cons."}),"\n",(0,n.jsx)(t.p,{children:"In 2022, the IsaacScript community discovered a powerful new pattern for writing Isaac mods: using TypeScript classes to represent individual mod features. This pattern is extremely powerful for a few reasons:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:'It allows you to use method decorators to subscribe individual class methods to callbacks. This allows you to get rid of callback files that "glue" together your "main.ts" file and your individual feature files.'}),"\n",(0,n.jsx)(t.li,{children:"Method decorators allow you to colocate the originating callback declaration alongside the actual code that is being executed. This makes the execution path much easier to read and understand."}),"\n",(0,n.jsx)(t.li,{children:"Classes allow you do provide conditional logic for decorated methods such that any callback will only fire if your logic passes. This allows you to very easily turn off individual mod features via e.g. Mod Config Menu or Dead Sea Scrolls."}),"\n",(0,n.jsxs)(t.li,{children:["Classes can be extended from parent classes, allowing you to unify initialization logic by writing it in the parent class constructor (e.g. ",(0,n.jsx)(t.code,{children:"MyNPC1"})," extends ",(0,n.jsx)(t.code,{children:"MyNPCFeatures"})," extends ",(0,n.jsx)(t.code,{children:"ModFeature"}),")."]}),"\n",(0,n.jsx)(t.li,{children:"Classes can subscribe and unsubscribe from callbacks when arbitrary conditions are met. This can be useful if your callback functions are expensive."}),"\n",(0,n.jsxs)(t.li,{children:["Classes automatically subscribe to the ",(0,n.jsx)(t.a,{href:"/isaacscript-common/features/SaveDataManager/",children:"save data manager"}),", which reduces boilerplate."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"In short, feature classes are a powerful abstraction that allows you to write concise, easy-to-read code. They also provide a great deal of flexibility and control."}),"\n",(0,n.jsx)(t.br,{}),"\n",(0,n.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,n.jsx)(t.p,{children:"Let's start with a quick example to showcase the power of the feature class pattern. We will be creating an item called the Green Candle. We won't fully implement the item; we just want you to get the idea of how the pattern works."}),"\n",(0,n.jsx)(t.p,{children:"First off, we create a mod and upgrade it so that we can use features with the standard library:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:'// mod.ts\n\nimport { ISCFeature, upgradeMod } from "isaacscript-common";\n\nconst ISC_FEATURES_FOR_THIS_MOD = [ISCFeature.SAVE_DATA_MANAGER] as const;\n\nconst modVanilla = RegisterMod("Green Candle", 1);\nexport const mod = upgradeMod(modVanilla, ISC_FEATURES_FOR_THIS_MOD);\n'})}),"\n",(0,n.jsx)(t.p,{children:"This part is pretty standard practice for all IsaacScript mods."}),"\n",(0,n.jsx)(t.p,{children:"Next, we define a class that will contain the logic for the Green Candle feature:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:'// features/GreenCandle.ts\n\nimport { ModCallback } from "isaac-typescript-definitions";\nimport { Callback, DefaultMap, ModFeature } from "isaacscript-common";\n\n// We create a typical "v" object to hold our variables for this feature. (Hopefully at this point\n// you have already written an IsaacScript mod and are familiar with the save data manager. If not,\n// that\'s okay; the the takeaway here is that "v" objects have special meaning.)\nconst v = {\n  room: {\n    countersMap: new DefaultMap<PtrHash, int>(0),\n  },\n};\n\n// Mod classes should extend from the `ModFeature` class. This allows their methods to be decorated\n// by the `@Callback` and `@CallbackCustom` decorator functions.\nexport class GreenCandle extends ModFeature {\n  // Whatever we specify as the class member of `v` will automatically be registered with the save\n  // data manager. Note that we could also declare `v` entirely inside the class, but it is\n  // conventional to do it this way so that we can type `v.room.countersMap` instead of\n  // `this.v.room.countersMap`.\n  v = v;\n\n  // By putting `@Callback` before a method, it decorates that method, which runs special logic\n  // upon class instantiation. In this case, it subscribes to the specified callback. Note that\n  // similar to a "real" callback registration, you could also provide an additional argument here\n  // to make the class method only fire for a specific kind of NPC.\n  @Callback(ModCallback.POST_NPC_UPDATE)\n  postNPCUpdate(npc: EntityNPC): void {\n    // The following code is just to show off getting a counter from our `v` object; it does not\n    // have to do with the class pattern specifically. Most of your mod features will probably use\n    // the save data manager in a way similar to this, but they don\'t necessarily have to.\n    const ptrHash = GetPtrHash(npc);\n    const counters = v.room.countersMap.getAndSetDefault(ptrHash);\n    const newCounters = counters + 1;\n    v.room.countersMap.set(ptrHash, newCounters);\n\n    // TODO: Do something with `newCounters`.\n  }\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:['Now, we can instantiate our mod feature classes in our "main.ts" file by using the ',(0,n.jsx)(t.code,{children:"initModFeatures"})," helper function:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:'// main.ts\n\nimport { initModFeatures } from "isaacscript-common";\nimport { GreenCandle } from "./features/GreenCandle";\nimport { mod } from "./mod";\n\nconst MOD_FEATURES = [GreenCandle] as const;\n\ninitModFeatures(mod, MOD_FEATURES);\n'})}),"\n",(0,n.jsx)(t.p,{children:"That's it! The code in our Green Candle class will now automatically run whenever an NPC is present."}),"\n",(0,n.jsxs)(t.p,{children:["As our mod gets bigger, we can add more classes to the ",(0,n.jsx)(t.code,{children:"MOD_FEATURES"})," array. We could also create an intermediary class if two or more mod features will have shared logic (e.g. ",(0,n.jsx)(t.code,{children:"GreenCandle extends CollectibleModFeature"})," + ",(0,n.jsx)(t.code,{children:"CollectibleModFeature extends ModFeature"}),")."]}),"\n",(0,n.jsx)(t.br,{}),"\n",(0,n.jsxs)(t.h2,{id:"other-modfeature-features",children:["Other ",(0,n.jsx)(t.code,{children:"ModFeature"})," Features"]}),"\n",(0,n.jsxs)(t.p,{children:["More advanced features of the ",(0,n.jsx)(t.code,{children:"ModFeature"})," class are listed below."]}),"\n",(0,n.jsx)(t.h3,{id:"decorators",children:"Decorators"}),"\n",(0,n.jsxs)(t.p,{children:["In addition to ",(0,n.jsx)(t.code,{children:"@Callback"}),", you can also use ",(0,n.jsx)(t.code,{children:"@CallbackCustom"})," to register class methods with custom callbacks from the standard library. You can also use ",(0,n.jsx)(t.code,{children:"@PriorityCallback"})," and ",(0,n.jsx)(t.code,{children:"@PriorityCallbackCustom"})," to make a certain method run before or after other registered callbacks."]}),"\n",(0,n.jsxs)(t.h3,{id:"using-shouldcallbackmethodsfire-for-conditional-firing",children:["Using ",(0,n.jsx)(t.code,{children:"shouldCallbackMethodsFire"})," For Conditional Firing"]}),"\n",(0,n.jsxs)(t.p,{children:["If you want the decorated methods of a class to conditionally fire, then specify a function for the ",(0,n.jsx)(t.code,{children:"shouldCallbackMethodsFire"})," property. For example:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"export class GreenCandle extends ModFeature {\n  protected override shouldCallbackMethodsFire = (): boolean => {\n    // We don't need to track anything if no players have the collectible.\n    return anyPlayerHasCollectible(CollectibleTypeCustom.GREEN_CANDLE);\n  };\n\n  // [The rest of the class logic goes here.]\n}\n"})}),"\n",(0,n.jsx)(t.h3,{id:"delayed-initialization",children:"Delayed Initialization"}),"\n",(0,n.jsxs)(t.p,{children:["We recommend that you use the ",(0,n.jsx)(t.code,{children:"initModFeatures"})," helper function to instantiate your mod features. That way, the ",(0,n.jsx)(t.code,{children:"v"})," variables will be properly registered with the save data manager."]}),"\n",(0,n.jsxs)(t.p,{children:["By default, when a ",(0,n.jsx)(t.code,{children:"ModFeature"})," is instantiated, it will immediately subscribe all of the decorated methods. If you want to defer the callback subscription for some reason, then you can manually instantiate your mod features by passing ",(0,n.jsx)(t.code,{children:"false"})," to the third argument of the constructor like this:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"const instantiatedModFeatures = initModFeatures(mod, modFeatures, false);\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Now, ",(0,n.jsx)(t.code,{children:"instantiatedModFeatures"})," will contain an array of the instantiated feature classes, but none of the callbacks will be subscribed and the variables will not be registered with the save data manager. Later on, when you actually need to use a class, you can initialize it with the ",(0,n.jsx)(t.code,{children:"init"})," method:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:'const firstInstantiatedModFeature = instantiatedModFeatures[0];\nif (firstInstantiatedModFeature === undefined) {\n  error("Failed to get the first instantiated mod feature.");\n}\n\nfirstInstantiatedModFeature.init();\n'})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},71184:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>r});var n=a(14041);const o={},s=n.createContext(o);function i(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);