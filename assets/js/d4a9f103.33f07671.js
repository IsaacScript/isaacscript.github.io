"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[74401],{93813:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>a});var s=n(31085),i=n(71184);const r={custom_edit_url:null},c="Merge",o={id:"isaacscript-common/functions/merge",title:"Merge",description:"Functions",source:"@site/docs/isaacscript-common/functions/merge.md",sourceDirName:"isaacscript-common/functions",slug:"/isaacscript-common/functions/merge",permalink:"/isaacscript-common/functions/merge",draft:!1,unlisted:!1,editUrl:null,tags:[],version:"current",frontMatter:{custom_edit_url:null},sidebar:"isaacScriptCommon",previous:{title:"Math",permalink:"/isaacscript-common/functions/math"},next:{title:"Merge Tests",permalink:"/isaacscript-common/functions/mergeTests"}},l={},a=[{value:"Functions",id:"functions",level:2},{value:"merge",id:"merge-1",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns",level:4},{value:"Defined in",id:"defined-in",level:4}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"merge",children:"Merge"}),"\n",(0,s.jsx)(t.h2,{id:"functions",children:"Functions"}),"\n",(0,s.jsx)(t.h3,{id:"merge-1",children:"merge"}),"\n",(0,s.jsxs)(t.p,{children:["\u25b8 ",(0,s.jsx)(t.strong,{children:"merge"}),"(",(0,s.jsx)(t.code,{children:"oldObject"}),", ",(0,s.jsx)(t.code,{children:"newTable"}),", ",(0,s.jsx)(t.code,{children:"traversalDescription"}),", ",(0,s.jsx)(t.code,{children:"classConstructors?"}),"): ",(0,s.jsx)(t.code,{children:"void"})]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"merge"})," takes the values from a new table and recursively merges them into an old object (while\nperforming appropriate deserialization)."]}),"\n",(0,s.jsx)(t.p,{children:'This function is used to merge incoming data from the "save#.dat" file into a mod\'s variables.\nMerging is useful instead of blowing away a table entirely because mod code often relies on the\nlocal table/object references.'}),"\n",(0,s.jsxs)(t.p,{children:["This function always assumes that the new table is serialized data and will attempt to perform\ndeserialization on the objects within. In other words, unlike the ",(0,s.jsx)(t.code,{children:"deepCopy"})," function, the\n",(0,s.jsx)(t.code,{children:"merge"})," function will always operates in the mode of ",(0,s.jsx)(t.code,{children:"SerializationType.DESERIALIZE"}),". For the\ntypes of objects that will be deserialized, see the documentation for the ",(0,s.jsx)(t.code,{children:"deepCopy"})," function."]}),"\n",(0,s.jsxs)(t.p,{children:["This function does not iterate over the old object, like you would naively expect. This is\nbecause it is common for a variable to have a type of ",(0,s.jsx)(t.code,{children:"something | null"}),". If this is the case,\nthe key would not appear when iterating over the old object (because a value of null transpiles\nto nil, which means the table key does not exist). Thus, we must instead iterate over the new\nobject and copy the values backwards. The consequence of this is that ",(0,s.jsx)(t.code,{children:"merge"})," can copy over old\nvariables that are no longer used in the code, or copy over old variables of a different type,\nwhich can cause run-time errors. In such cases, users will have to manually delete their save\ndata."]}),"\n",(0,s.jsx)(t.h4,{id:"parameters",children:"Parameters"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"oldObject"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.code,{children:"ReadonlyMap"}),"<",(0,s.jsx)(t.code,{children:"AnyNotNil"}),", ",(0,s.jsx)(t.code,{children:"unknown"}),"> | ",(0,s.jsx)(t.code,{children:"Readonly"}),"<",(0,s.jsx)(t.code,{children:"LuaMap"}),"<",(0,s.jsx)(t.code,{children:"AnyNotNil"}),", ",(0,s.jsx)(t.code,{children:"unknown"}),">> | ",(0,s.jsx)(t.code,{children:"ReadonlySet"}),"<",(0,s.jsx)(t.code,{children:"AnyNotNil"}),">"]}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"The old object to merge the values into. This can be either a Lua table, a TSTL map, or a TSTL set."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"newTable"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.code,{children:"LuaMap"}),"<",(0,s.jsx)(t.code,{children:"AnyNotNil"}),", ",(0,s.jsx)(t.code,{children:"unknown"}),">"]}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["The new table to merge the values from. This must be a Lua table that represents serialized data. In other words, it should be created with the ",(0,s.jsx)(t.code,{children:"deepCopy"})," function using ",(0,s.jsx)(t.code,{children:"SerializationType.SERIALIZE"}),"."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"traversalDescription"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"string"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Used to track the current key that we are operating on for debugging purposes. Use a name that corresponds to the name of the merging table."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"classConstructors"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.code,{children:"LuaMap"}),"<",(0,s.jsx)(t.code,{children:"string"}),", ",(0,s.jsx)(t.a,{href:"/isaacscript-common/other/types/AnyClass#anyclass",children:(0,s.jsx)(t.code,{children:"AnyClass"})}),">"]}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Optional. A Lua table that maps the name of a user-defined TSTL class to its corresponding constructor. If the ",(0,s.jsx)(t.code,{children:"deepCopy"})," function finds any user-defined TSTL classes when recursively iterating through the given object, it will use this map to instantiate a new class. Default is an empty Lua table."]})]})]})]}),"\n",(0,s.jsx)(t.h4,{id:"returns",children:"Returns"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.code,{children:"void"})}),"\n",(0,s.jsx)(t.h4,{id:"defined-in",children:"Defined in"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://github.com/IsaacScript/isaacscript/blob/54ef116/packages/isaacscript-common/src/functions/merge.ts#L54",children:"packages/isaacscript-common/src/functions/merge.ts:54"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},71184:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>o});var s=n(14041);const i={},r=s.createContext(i);function c(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);