"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[97794],{9166:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var n=a(31085),s=a(71184);const i={title:"Using Entity.GetData and the Save Data Manager"},o=void 0,r={id:"main/using-get-data",title:"Using Entity.GetData and the Save Data Manager",description:"A common task in Isaac mods is to make new enemies, new familiars, and so on. All of these things are grouped under the umbrella of the Entity class. Custom entities often have some state associated with them. For example, you might have a custom familiar that eats bombs. In this case, you would need to keep track of how many bombs it has eaten already.",source:"@site/docs/main/using-get-data.md",sourceDirName:"main",slug:"/main/using-get-data",permalink:"/main/using-get-data",draft:!1,unlisted:!1,editUrl:"https://github.com/IsaacScript/isaacscript/edit/main/packages/docs/docs/main/using-get-data.md",tags:[],version:"current",frontMatter:{title:"Using Entity.GetData and the Save Data Manager"},sidebar:"docs",previous:{title:"Next Steps",permalink:"/main/next-steps"},next:{title:"The Difference Between Enums and Objects",permalink:"/main/enums-and-objects"}},l={},d=[{value:"Using <code>Entity.GetData</code>",id:"using-entitygetdata",level:2},{value:"Downsides of <code>Entity.GetData</code>",id:"downsides-of-entitygetdata",level:2},{value:"It&#39;s a Global Variable",id:"its-a-global-variable",level:3},{value:"It&#39;s Ephemeral",id:"its-ephemeral",level:3},{value:"It&#39;s <em>Really</em> Ephemeral",id:"its-really-ephemeral",level:3},{value:"Using Local Variables Instead",id:"using-local-variables-instead",level:2},{value:"Save Data Manager Setup",id:"save-data-manager-setup",level:3},{value:"Data Definition",id:"data-definition",level:3},{value:"Local Variables",id:"local-variables",level:3},{value:"<code>DefaultMap</code>",id:"defaultmap",level:3},{value:"Tracking Other Kinds of Entities",id:"tracking-other-kinds-of-entities",level:2},{value:"Saving and Continuing",id:"saving-and-continuing",level:2},{value:"Storing Other Variables",id:"storing-other-variables",level:2}];function c(e){const t={a:"a",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["A common task in Isaac mods is to make new enemies, new familiars, and so on. All of these things are grouped under the umbrella of the ",(0,n.jsx)(t.code,{children:"Entity"})," class. Custom entities often have some state associated with them. For example, you might have a custom familiar that eats bombs. In this case, you would need to keep track of how many bombs it has eaten already."]}),"\n",(0,n.jsx)(t.p,{children:"Additionally, a common task in modding is to make new functionality for vanilla entities. For example, you might want to make a custom collectible that inflicts sleep counters on all NPCs. In this case, you would need to keep track of a sleep counter for every NPC."}),"\n",(0,n.jsx)(t.p,{children:"These are just two examples. Regardless of the specific thing that you need to do, if you need to store data about an entity, then you have a few different options."}),"\n",(0,n.jsx)(t.br,{}),"\n",(0,n.jsxs)(t.h2,{id:"using-entitygetdata",children:["Using ",(0,n.jsx)(t.code,{children:"Entity.GetData"})]}),"\n",(0,n.jsxs)(t.p,{children:["There is a helpful method on the ",(0,n.jsx)(t.code,{children:"Entity"})," class called ",(0,n.jsx)(t.code,{children:"GetData"}),". It returns a table that allows you to store arbitrary key/value pairs. Since the data is attached to the ",(0,n.jsx)(t.code,{children:"Entity"})," class, it can be easily retrieved from any callback."]}),"\n",(0,n.jsxs)(t.p,{children:["Unfortunately, ",(0,n.jsx)(t.code,{children:"GetData"})," has many downsides, but we will get to that later."]}),"\n",(0,n.jsxs)(t.p,{children:["To start with, the return type of ",(0,n.jsx)(t.code,{children:"GetData"})," is ",(0,n.jsx)(t.code,{children:"Record<string, unknown>"}),", which is essentially untyped. The first thing you will want to do is define the structure of the data that you will be storing on the entity. This is done by declaring an ",(0,n.jsx)(t.a,{href:"https://www.typescriptlang.org/docs/handbook/2/objects.html",children:"interface"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"For example, say that we want to store sleep counters on an entity. And when the counter reaches a certain value, then the enemy will fall asleep."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"interface FooData {\n  sleepCounters: int | undefined;\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Here, the ",(0,n.jsx)(t.code,{children:"|"})," symbol creates a ",(0,n.jsx)(t.a,{href:"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types",children:"type union"}),". In other words, the type is \"an integer or undefined\". (It can't just be an integer because prior to us initializing it with a value, it won't exist at all.)"]}),"\n",(0,n.jsx)(t.p,{children:"Once the interface is declared, we can use a type assertion to make retrieving the counters type safe:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"const data = entity.GetData() as FooData;\nprint(`Sleep counters: ${data.sleepCounters}`); // Auto-completes and is type safe!\nif (data.sleepCounters === undefined) {\n  // Initialize the sleep counters to an initial value.\n  data.sleepCounters = 0;\n}\n\n// Do something with the sleep counters.\n"})}),"\n",(0,n.jsx)(t.br,{}),"\n",(0,n.jsxs)(t.h2,{id:"downsides-of-entitygetdata",children:["Downsides of ",(0,n.jsx)(t.code,{children:"Entity.GetData"})]}),"\n",(0,n.jsx)(t.h3,{id:"its-a-global-variable",children:"It's a Global Variable"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"GetData"})," table is a global variable, meaning that all mods share the same table. Thus, there can be conflicts, and other mods can modify or destroy your data. Carefully namespacing your variable names can mitigate this problem, but it's still not a good solution if you want your mod to be perfect."]}),"\n",(0,n.jsx)(t.h3,{id:"its-ephemeral",children:"It's Ephemeral"}),"\n",(0,n.jsx)(t.p,{children:"The table is ephemeral, meaning that when the entity despawns, the table will be deleted and you will lose your data."}),"\n",(0,n.jsxs)(t.p,{children:["For example, pickups are a type of entity that appear to be persistent: when you get a heart drop in one room, you can backtrack to that room later, and the heart drop will still be there. However, behind the scenes, what is really happening is that the heart drop is despawned when you leave the room, and then a brand-new heart pickup entity is respawned when you re-enter the room. In this situation, if you had previously stored data on the ",(0,n.jsx)(t.code,{children:"GetData"})," table of the heart pickup, the brand-new entity would not have this same data."]}),"\n",(0,n.jsxs)(t.h3,{id:"its-really-ephemeral",children:["It's ",(0,n.jsx)(t.em,{children:"Really"})," Ephemeral"]}),"\n",(0,n.jsxs)(t.p,{children:["Even for real persistent entities like players and familiars, the table is still ephemeral. For example, a familiar is never despawned; the same entity continues to exist as the player moves from room to room. Thus, the problem in the previous section would not apply to data stored in the ",(0,n.jsx)(t.code,{children:"GetData"})," table for a familiar. However, once the player saves and quits and continues, the familiar will also be despawned in the exact same way that the heart drop was, and all of the data will be lost. Saving and quitting and continuing is a common thing for players to do (so that they can finish the run at a later time), so any well-designed mod must be able to handle this case."]}),"\n",(0,n.jsx)(t.br,{}),"\n",(0,n.jsx)(t.h2,{id:"using-local-variables-instead",children:"Using Local Variables Instead"}),"\n",(0,n.jsxs)(t.p,{children:["Using the IsaacScript save data manager, it's relatively easy to replace ",(0,n.jsx)(t.code,{children:"Entity.GetData"})," variables with a standard object. Let's use the same example as before: we store sleep counters for every NPC in the room, and once they get enough counters, they fall asleep."]}),"\n",(0,n.jsx)(t.h3,{id:"save-data-manager-setup",children:"Save Data Manager Setup"}),"\n",(0,n.jsx)(t.p,{children:"First, before we declare our sleep counter variables, we need to upgrade our mod with the save data manager feature:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:'// mod.ts\nimport { upgradeMod } from "isaacscript-common";\n\nconst modVanilla = RegisterMod("my-mod", 1);\nconst features = [ISCFeature.SAVE_DATA_MANAGER] as const;\nexport const mod = upgradeMod(modVanilla, features);\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Now, the ",(0,n.jsx)(t.code,{children:"mod"})," object can be imported by the feature files in our project. (If this part is confusing, you might want to first look at ",(0,n.jsxs)(t.a,{href:"/isaacscript-common",children:["the documentation for ",(0,n.jsx)(t.code,{children:"isaacscript-common"})]}),".)"]}),"\n",(0,n.jsx)(t.h3,{id:"data-definition",children:"Data Definition"}),"\n",(0,n.jsx)(t.p,{children:"Since we just need to store sleep counters, we could use the exact same interface as the previous example, and it would work just fine. But here, it makes sense to use a class, because we can leverage the constructor to initialize default values without having to manually write any custom code. (All NPCs should start with 0 counters to begin with.)"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"class FooData {\n  sleepCounters = 0;\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["And when we need to initialize the data, we can simply do: ",(0,n.jsx)(t.code,{children:"new FooData()"})]}),"\n",(0,n.jsx)(t.h3,{id:"local-variables",children:"Local Variables"}),"\n",(0,n.jsx)(t.p,{children:"Next, we need to define a local object to store our variables for the entity, and then feed it to the save data manager:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:'const v = {\n  room: {\n    fooData: new Map<PtrHash, FooData>(),\n  },\n};\n\nmod.saveDataManager("foo", v);\n'})}),"\n",(0,n.jsx)(t.p,{children:"Let's break this down."}),"\n",(0,n.jsxs)(t.p,{children:["The object name of ",(0,n.jsx)(t.code,{children:"v"}),' is conventionally used to denote "variables", or more specifically, "variables that are local to this file or feature only". We would stick every variable that we need for this sleep feature on the ',(0,n.jsx)(t.code,{children:"v"})," object. (And we would not put any other variables on it, to keep the variables scoped properly.)"]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"v"})," is composed of sub-objects. By specifying a ",(0,n.jsx)(t.code,{children:"room"})," sub-object, that tells the save data manager to automatically wipe the data in that sub-object when a new room is entered. This is what we want, because in this example, enemy NPCs will only exist in the context of the current room, and we don't care about keeping data for NPCs that have already despawned."]}),"\n",(0,n.jsxs)(t.p,{children:["Finally, inside of the ",(0,n.jsx)(t.code,{children:"room"})," sub-object, we define the ",(0,n.jsx)(t.code,{children:"fooData"})," map. (If you don't know what a ",(0,n.jsx)(t.code,{children:"Map"})," is, read the ",(0,n.jsx)(t.a,{href:"/main/javascript-tutorial#maps",children:"JavaScript/TypeScript tutorial"}),", as understanding maps is essential for this section.) The ",(0,n.jsx)(t.code,{children:"fooData"})," map is two-dimensional in that it will contain the data for every NPC in the room."]}),"\n",(0,n.jsxs)(t.p,{children:["So, we need a way to identify each NPC in the room, and then use this identifier as the index in our map. The solution is to use the pointer hash, which a unique string that can be retrieved with the global function ",(0,n.jsx)(t.code,{children:"GetPtrHash"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"const ptrHash = GetPtrHash(entity);\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Imagine that we are in the ",(0,n.jsx)(t.code,{children:"POST_ENTITY_DMG"})," callback, and an NPC has just gotten hit by the player's tear. So now, we want to increment the number of sleep counters:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"function incrementSleepCounter(npc: EntityNPC) {}\n  const ptrHash = GetPtrHash(npc);\n  let data = v.run.fooData.get(ptrHash);\n  if (data === undefined) {\n    data = new FooData();\n    v.run.fooData.set(data);\n  }\n\n  data.sleepCounters += 1;\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["That's about all there is to it. Here, the ",(0,n.jsx)(t.code,{children:"FooData"})," class corresponds to the old ",(0,n.jsx)(t.code,{children:"GetData"})," table. You can add as many variables to the class as you need."]}),"\n",(0,n.jsx)(t.h3,{id:"defaultmap",children:(0,n.jsx)(t.code,{children:"DefaultMap"})}),"\n",(0,n.jsxs)(t.p,{children:["The previous example is a very common pattern in Isaac modding. The IsaacScript standard library offers a data structure called a ",(0,n.jsx)(t.code,{children:"DefaultMap"})," that can simplify this pattern even further. A ",(0,n.jsx)(t.code,{children:"DefaultMap"})," allows you to specify a default value for things in the map. Subsequently, you don't have to worry about checking for the case where the data doesn't exist yet, because the ",(0,n.jsx)(t.code,{children:"DefaultMap"})," automatically instantiates it for you."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"const v = {\n  room: {\n    fooData: new DefaultMap<PtrHash, FooData>(() => new FooData()),\n  },\n};\n\nfunction incrementSleepCounter(npc: EntityNPC) {}\n  const ptrHash = GetPtrHash(npc);\n  const data = v.run.fooData.getAndSetDefault(ptrHash);\n  data.sleepCounters += 1;\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"Let's break this down."}),"\n",(0,n.jsx)(t.p,{children:"You specify the default value of the map with the first argument of the constructor. The first argument can either be a raw value, like 0. Or, it can be a function that dynamically calculates/creates a value. Here, we pass a very simple function that just instantiates a new class."}),"\n",(0,n.jsxs)(t.p,{children:["In the ",(0,n.jsx)(t.code,{children:"incrementSleepCounter"})," function, we use the ",(0,n.jsx)(t.code,{children:"getAndSetDefault"})," method instead of the ",(0,n.jsx)(t.code,{children:"get"})," method. If the monster already exists in the map, then the ",(0,n.jsx)(t.code,{children:"getAndSetDefault"})," will do the same thing as the ",(0,n.jsx)(t.code,{children:"get"})," method. If the monster does not exist yet in the map, the ",(0,n.jsx)(t.code,{children:"DefaultMap"})," will run the function we provided and give us the new data."]}),"\n",(0,n.jsxs)(t.p,{children:["Using the ",(0,n.jsx)(t.code,{children:"DefaultMap"})," data structure allows us to write really compact and easy-to-read code!"]}),"\n",(0,n.jsx)(t.br,{}),"\n",(0,n.jsx)(t.h2,{id:"tracking-other-kinds-of-entities",children:"Tracking Other Kinds of Entities"}),"\n",(0,n.jsx)(t.p,{children:"In the previous example, we used the save data manager to track data about entities that only exist in the context of a single room. However, mods will also commonly want to store data about players. Players exist for an entire run, not just a single room. This means that a slightly different approach is necessary."}),"\n",(0,n.jsxs)(t.p,{children:["For this case, instead of using ",(0,n.jsx)(t.code,{children:"GetPtrHash"}),", you can use ",(0,n.jsx)(t.code,{children:"getPlayerIndex"}),". (The corresponding type is ",(0,n.jsx)(t.code,{children:"PlayerIndex"}),".)"]}),"\n",(0,n.jsxs)(t.p,{children:["So, for example, you might have a ",(0,n.jsx)(t.code,{children:"v"})," that looks something like this:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"const v = {\n  run: {\n    playerCounters: new DefaultMap<PlayerIndex, int>(0),\n  },\n};\n"})}),"\n",(0,n.jsxs)(t.p,{children:["For pickups, use ",(0,n.jsx)(t.code,{children:"getPickupIndex"}),". (The corresponding type is ",(0,n.jsx)(t.code,{children:"PickupIndex"}),".)"]}),"\n",(0,n.jsxs)(t.p,{children:["For familiars (and Dark Esau), use the ",(0,n.jsx)(t.code,{children:"Entity.InitSeed"}),". (The corresponding type is ",(0,n.jsx)(t.code,{children:"Seed"}),".)"]}),"\n",(0,n.jsx)(t.h2,{id:"saving-and-continuing",children:"Saving and Continuing"}),"\n",(0,n.jsx)(t.p,{children:"A huge benefit of using the save data manager is that any variables you create will be automatically saved to disk if the player decides to save and quit the run."}),"\n",(0,n.jsxs)(t.p,{children:["In the first example above, we were adding sleep counters to enemy NPCs. For this case, the save data manager wouldn't actually save anything, because nothing in ",(0,n.jsx)(t.code,{children:"room"})," sub-object needs to be permanently saved. (Since the player reloads the room when continuing the game, the ",(0,n.jsx)(t.code,{children:"room"})," object is flushed in the same way that it is flushed when the player enters a new room normally. For this reason, saving any of the ",(0,n.jsx)(t.code,{children:"room"})," values would be superfluous.)"]}),"\n",(0,n.jsx)(t.p,{children:"In the second example above, we were tracking counters on players. For this case, since players exist over the course of the entire run, the save data manager would automatically save everything without you having to worry about anything at all! (This is magic that would take around a thousand of lines of code to write yourself.)"}),"\n",(0,n.jsx)(t.h2,{id:"storing-other-variables",children:"Storing Other Variables"}),"\n",(0,n.jsxs)(t.p,{children:["The point of this article is to showcase how you can use a local object to store data about an entity as an alternative to using ",(0,n.jsx)(t.code,{children:"GetData"}),". But note that in IsaacScript mods, using ",(0,n.jsx)(t.code,{children:"v"})," is the typical way to store data about anything, not just entities. Your ",(0,n.jsx)(t.code,{children:"v"})," object will contain all the variables needed to make your feature work. So using the ",(0,n.jsx)(t.code,{children:"v"})," pattern is very powerful."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},71184:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>r});var n=a(14041);const s={},i=n.createContext(s);function o(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);